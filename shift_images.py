"""
Скрипт для генерации набора обучающих изображений с имитацией смещений (без поворотов).

Назначение:
- Загружает исходные изображения из директории 'raw'
- Для каждого изображения создаёт 120 уникальных кропов 300x300 пикселей:
  * Со случайными смещениями центра в диапазоне ±15 пикселей по X/Y
  * Без поворотов (фиксированный угол 0°)
- Гарантирует уникальность смещений и исключает дублирование параметров
- Сохраняет кропы в структурированную директорию 'angles/images' с именами,
  кодирующими параметры смещения
- Дополнительно сохраняет центральный кроп без смещения (эталон с нулевым сдвигом)

Формат имён файлов:
  dx_dy_0p00.jpg
  Пример: "3p0_m2p0_0p00.jpg" → смещение +3.0 по X, -2.0 по Y, угол 0.00°
  Особенности кодировки:
    '.' → 'p' (point)
    '-' → 'm' (minus)
    Целые значения форматируются с одним знаком после запятой (3 → "3p0")
"""

import os
import cv2
import numpy as np
from pathlib import Path
from sys import path


# Директории для входных и выходных данных
RAW_DIR = Path(path[0] + "\\raw")          # Исходные изображения (входная директория)
ANGLES_DIR = Path(path[0] + "\\angles\\images")  # Выходные кропы со смещениями

# Параметры генерации
CROP_SIZE = 300          # Размер квадратного кропа (пиксели)
MAX_OFFSET = 15.0        # Максимальное смещение центра кропа от центра изображения (пиксели)
NUM_CROPS = 120          # Количество уникальных кропов для генерации на одно исходное изображение

# Поддерживаемые форматы изображений (регистронезависимо)
SUPPORTED_EXTS = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff'}


def get_image_files(directory):
    """
    Сканирует директорию и возвращает список путей к изображениям с поддерживаемыми расширениями.
    
    :param directory: Путь к директории для сканирования
    :return: Список объектов Path, указывающих на найденные изображения
    """
    files = []
    for f in os.listdir(directory):
        if Path(f).suffix.lower() in SUPPORTED_EXTS:
            files.append(Path(directory) / f)
    return files


def shift_center_crop(img, dx, dy):
    """
    Извлекает квадратный кроп заданного размера со смещённым центром.
    
    Особенности:
      - Центр кропа смещается относительно геометрического центра изображения
      - Автоматическая коррекция выхода за границы изображения (без интерполяции)
      - Возвращает кроп меньшего размера, если смещение выходит за границы
    
    :param img: Исходное изображение (2D массив)
    :param dx: Смещение центра по оси X (пиксели, положительное → вправо)
    :param dy: Смещение центра по оси Y (пиксели, положительное → вниз)
    :return: Кропированное изображение (массив пикселей)
    """
    h, w = img.shape[:2]
    # Вычисление нового центра кропа с учётом смещения
    cy, cx = h // 2 + dy, w // 2 + dx
    
    # Расчёт координат кропа с защитой от выхода за границы изображения
    y1 = max(0, cy - CROP_SIZE // 2)
    x1 = max(0, cx - CROP_SIZE // 2)
    y2 = min(h, y1 + CROP_SIZE)
    x2 = min(w, x1 + CROP_SIZE)
    
    return img[y1:y2, x1:x2]


def crop_center(img):
    """
    Извлекает центральный квадратный кроп без смещения.
    
    :param img: Исходное изображение
    :return: Центральный кроп или None, если изображение слишком мало для кропа
    """
    h, w = img.shape[:2]
    cx, cy = w // 2, h // 2
    half = CROP_SIZE // 2
    left_i = cx - half
    top_i = cy - half

    # Проверка возможности извлечения полноразмерного кропа
    if left_i < 0 or top_i < 0 or left_i + CROP_SIZE > w or top_i + CROP_SIZE > h:
        return None

    return img[top_i:top_i + CROP_SIZE, left_i:left_i + CROP_SIZE]


def main():
    """
    Основной цикл генерации обучающих кропов со смещениями.
    
    Алгоритм работы:
      1. Создание выходной директории (если не существует)
      2. Поиск всех изображений в RAW_DIR
      3. Для каждого изображения:
          - Загрузка в градациях серого (оптимизация памяти и скорости)
          - Проверка минимального размера (должен быть ≥ CROP_SIZE)
          - Генерация ровно NUM_CROPS уникальных кропов:
              * Случайные смещения в диапазоне [-MAX_OFFSET+1, MAX_OFFSET)
              * Исключение дубликатов и нулевого смещения (0,0) на этапе генерации
              * Повторная генерация при неудачных смещениях (выход за границы)
          - Сохранение эталонного кропа с нулевым смещением (0,0)
      4. Кодирование параметров смещения в имени файла для последующего анализа
    """
    # Создание структуры выходных директорий (рекурсивно)
    ANGLES_DIR.mkdir(parents=True, exist_ok=True)
    
    # Получение списка исходных изображений
    image_files = get_image_files(RAW_DIR)

    # Проверка наличия изображений для обработки
    if not image_files:
        print(f"Нет изображений в {RAW_DIR} с поддерживаемыми расширениями: {SUPPORTED_EXTS}")
        return

    # Обработка каждого исходного изображения
    for img_path in image_files:
        print(f"Обработка: {img_path.name}")
        
        # Загрузка изображения в градациях серого (оптимально для задач сопоставления)
        img = cv2.imread(str(img_path), cv2.IMREAD_GRAYSCALE)
        if img is None:
            print(f"Не удалось загрузить: {img_path} (неподдерживаемый формат или повреждённый файл)")
            continue

        # Проверка минимального размера изображения
        h, w = img.shape[:2]
        if w < CROP_SIZE or h < CROP_SIZE:
            print(f"Изображение слишком маленькое ({w}x{h}), минимальный размер: {CROP_SIZE}x{CROP_SIZE}")
            continue

        # Создание поддиректории для кропов текущего изображения
        out_dir = ANGLES_DIR / ("shift_" + img_path.stem)
        out_dir.mkdir(exist_ok=True)

        saved = 0
        all_shifts = []  # Хранилище уникальных смещений для предотвращения дубликатов

        # Генерация ровно NUM_CROPS уникальных кропов
        while saved < NUM_CROPS:
            # Генерация случайного смещения в заданном диапазоне
            # +1 в нижней границе предотвращает слишком частое появление нулевых смещений
            dx = int(np.random.uniform(-MAX_OFFSET + 1, MAX_OFFSET))
            dy = int(np.random.uniform(-MAX_OFFSET + 1, MAX_OFFSET))
            
            # Пропуск дубликатов и нулевого смещения (нулевое будет сохранено отдельно)
            if (dx, dy) in all_shifts or (dx, dy) == (0, 0):
                continue

            # Получение кропа со смещённым центром
            crop = shift_center_crop(img, dx, dy)
            
            # Пропуск некорректных кропов (слишком маленьких из-за выхода за границы)
            if crop.shape[0] != CROP_SIZE or crop.shape[1] != CROP_SIZE:
                continue

            # Форматирование параметров смещения для имени файла:
            # Пример: dx=3 → "3.0" → "3p0"; dx=-2 → "-2.0" → "m2p0"
            dx_str = f"{dx:.1f}".replace(".", "p").replace("-", "m")
            dy_str = f"{dy:.1f}".replace(".", "p").replace("-", "m")
            
            # Формирование имени файла: "смещение_X_смещение_Y_угол.jpg"
            # Угол всегда 0.00 (фиксированное значение для данной версии скрипта)
            filename = f"{dx_str}_{dy_str}_0p00.jpg"
            out_path = out_dir / filename
            
            # Сохранение кропа с оптимальным качеством JPEG
            cv2.imwrite(str(out_path), crop, [int(cv2.IMWRITE_JPEG_QUALITY), 95])
            
            # Регистрация использованного смещения и инкремент счётчика
            all_shifts.append((dx, dy))
            saved += 1

        # Сохранение эталонного кропа с нулевым смещением (центр изображения)
        # Этот кроп служит референсом для измерения относительных смещений
        center_crop = crop_center(img)
        if center_crop is not None:
            cv2.imwrite(str(out_dir / "0p0_0p0_0p00.jpg"), center_crop, 
                       [int(cv2.IMWRITE_JPEG_QUALITY), 95])
            print(f"Сохранено {saved} кропов + эталонный кроп в {out_dir.name}")
        else:
            print(f"Не удалось сохранить эталонный кроп (ошибка кадрирования)")

    print("\nГотово! Все изображения успешно обработаны.")


if __name__ == "__main__":
    main()