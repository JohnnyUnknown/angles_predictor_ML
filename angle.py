"""
–°–∫—Ä–∏–ø—Ç –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –∏ –æ—Ü–µ–Ω–∫–∏ –º–æ–¥–µ–ª–µ–π –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —É–≥–ª–∞ –ø–æ–≤–æ—Ä–æ—Ç–∞
–º–µ–∂–¥—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Ñ–∞–∑–æ–≤–æ–π –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏.

–û–°–ù–û–í–ù–ê–Ø –ó–ê–î–ê–ß–ê:
–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ä–µ–≥—Ä–µ—Å—Å–∏–æ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏, –∫–æ—Ç–æ—Ä–∞—è –ø–æ –∏–∑–º–µ—Ä–µ–Ω–Ω—ã–º –ª–æ–∫–∞–ª—å–Ω—ã–º —Å–º–µ—â–µ–Ω–∏—è–º (dx, dy)
–≤ 9 —Ä–µ–≥–∏–æ–Ω–∞—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (—Å–µ—Ç–∫–∞ 3√ó3) –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç —É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞ –º–µ–∂–¥—É –ø–∞—Ä–æ–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.

–ò–°–¢–û–ß–ù–ò–ö –î–ê–ù–ù–´–•:
- –û–±—É—á–∞—é—â–∏–π –¥–∞—Ç–∞—Å–µ—Ç: 'combined_data_angle.csv'
- –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: 18 —Å—Ç–æ–ª–±—Ü–æ–≤ (9 —Ç–∞–π–ª–æ–≤ √ó 2 –ø—Ä–∏–∑–Ω–∞–∫–∞: dx, dy)
- –¶–µ–ª–µ–≤–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è: 'angle' (—É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞ –≤ –≥—Ä–∞–¥—É—Å–∞—Ö, –¥–∏–∞–ø–∞–∑–æ–Ω [-3.0¬∞, +3.0¬∞])

–†–ï–ê–õ–ò–ó–û–í–ê–ù–ù–´–ï –ú–û–î–ï–õ–ò:
1. –õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è (–±–∞–∑–æ–≤—ã–π –±–µ–Ω—á–º–∞—Ä–∫)
2. Ridge-—Ä–µ–≥—Ä–µ—Å—Å–∏—è (–ª–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è —Å L2-—Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–µ–π)
3. Random Forest (–∞–Ω—Å–∞–º–±–ª—å –¥–µ—Ä–µ–≤—å–µ–≤ —Ä–µ—à–µ–Ω–∏–π)
4. XGBoost (–≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π –±—É—Å—Ç–∏–Ω–≥ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —á–µ—Ä–µ–∑ Optuna)

–û–°–û–ë–ï–ù–ù–û–°–¢–ò –û–¶–ï–ù–ö–ò:
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —É–≥–ª–æ–≤–æ–π –æ—à–∏–±–∫–∏ —Å —É—á—ë—Ç–æ–º —Ü–∏–∫–ª–∏—á–Ω–æ—Å—Ç–∏ (–¥–ª—è –æ–±—â–µ–≥–æ —Å–ª—É—á–∞—è)
- –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —á–µ—Ä–µ–∑ 3 –≥—Ä–∞—Ñ–∏–∫–∞:
  * –ò—Å—Ç–∏–Ω–Ω—ã–π vs –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–π —É–≥–æ–ª (–¥–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∞—è –¥–∏–∞–≥—Ä–∞–º–º–∞ —Ä–∞—Å—Å–µ—è–Ω–∏—è)
  * –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ (–≥–∏—Å—Ç–æ–≥—Ä–∞–º–º–∞)
  * –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—à–∏–±–∫–∏ –æ—Ç –≤–µ–ª–∏—á–∏–Ω—ã –∏—Å—Ç–∏–Ω–Ω–æ–≥–æ —É–≥–ª–∞
- –ú–µ—Ç—Ä–∏–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞: MAE, RMSE, 95-–π –ø–µ—Ä—Ü–µ–Ω—Ç–∏–ª—å –æ—à–∏–±–∫–∏
"""

import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path
import pandas as pd
from joblib import dump, load
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LinearRegression, RANSACRegressor, Ridge
from sklearn.metrics import mean_absolute_error
from sys import path
import optuna
from xgboost import XGBRegressor
from time import perf_counter
import seaborn as sns


def analysis():
    """
    –ü—Ä–æ–≤–æ–¥–∏—Ç —Ä–∞–∑–≤–µ–¥–æ—á–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö (EDA) –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞—Ç–∞—Å–µ—Ç–∞.
      1. –í—ã–≤–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ (—Å—Ä–µ–¥–Ω–µ–µ, –°–ö–û, –º–∏–Ω/–º–∞–∫—Å) –¥–ª—è –≤—Å–µ—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
      2. –ü—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (–≤ —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏—Ö –±—ã—Ç—å –Ω–µ –¥–æ–ª–∂–Ω–æ)
      3. –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã –¥–ª—è –≤—ã—è–≤–ª–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –º–µ–∂–¥—É –ø—Ä–∏–∑–Ω–∞–∫–∞–º–∏
    """
    print(round(all_data.describe().transpose(), 2))
    
    print(all_data.isnull().sum())

    corr_matrix = all_data.corr()
    plt.figure(figsize=(15, 10))
    sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f')
    plt.title('–ö–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞')
    plt.show()


def bayes_opt(X_train, y_train):
    """
    –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä—ã XGBoost —Å –ø–æ–º–æ—â—å—é –±–∞–π–µ—Å–æ–≤—Å–∫–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (Optuna).
    
    –ü–ê–†–ê–ú–ï–¢–†–´ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:
      - n_estimators: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ä–µ–≤—å–µ–≤ (40‚Äì300)
      - max_depth: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –¥–µ—Ä–µ–≤–∞ (3‚Äì10)
      - learning_rate: —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è (–ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —à–∫–∞–ª–∞ 0.01‚Äì0.3)
      - subsample: –¥–æ–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞ (0.6‚Äì1.0)
      - colsample_bytree: –¥–æ–ª—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞ (0.6‚Äì1.0)
    
    –í–û–ó–í–†–ê–©–ê–ï–¢:
      –°–ª–æ–≤–∞—Ä—å —Å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–º–∏ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ XGBRegressor
    """
    def objective(trial):
        params = {
            "n_estimators": trial.suggest_int("n_estimators", 40, 300),
            "eval_metric": "mae",
            "max_depth": trial.suggest_int("max_depth", 3, 10),
            "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3, log=True),
            "subsample": trial.suggest_float("subsample", 0.6, 1.0),
            "colsample_bytree": trial.suggest_float("colsample_bytree", 0.6, 1.0)
        }
        
        model = XGBRegressor(**params)
        scores = -cross_val_score(model, X_train, y_train, cv=3, scoring='neg_mean_absolute_error', n_jobs=-1)
        return scores.mean()

    print("\n–ó–∞–ø—É—Å–∫ Optuna...")
    study = optuna.create_study(direction="minimize")
    study.optimize(objective, n_trials=30, show_progress_bar=True)

    print("\n–õ—É—á—à–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (Optuna):")
    print(study.best_params)
    print(f"–õ—É—á—à–∏–π MAE: {study.best_value:.3f} px")

    return study.best_params


def angular_error_deg(y_true, y_pred):
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç –æ—à–∏–±–∫—É –º–µ–∂–¥—É –∏—Å—Ç–∏–Ω–Ω—ã–º–∏ –∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–º–∏ —É–≥–ª–∞–º–∏ (–≤ –≥—Ä–∞–¥—É—Å–∞—Ö)
    —Å —É—á—ë—Ç–æ–º —Ü–∏–∫–ª–∏—á–Ω–æ—Å—Ç–∏. –î–ª—è –º–∞–ª—ã—Ö —É–≥–ª–æ–≤ (-3..3) –ø–æ—á—Ç–∏ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø—Ä–æ—Å—Ç–æ–π —Ä–∞–∑–Ω–æ—Å—Ç—å—é.
    """
    y_true = np.asarray(y_true)
    y_pred = np.asarray(y_pred)
    diff = y_pred - y_true
    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ [-180, 180)
    errors = (diff + 180) % 360 - 180
    return errors


def evaluate_angle_predictions(y_true, y_pred, title="–û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —É–≥–ª–∞"):
    """
    –ü–æ–ª–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —É–≥–ª–∞ —Å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π.
    
    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        y_true : array-like ‚Äî –∏—Å—Ç–∏–Ω–Ω—ã–µ —É–≥–ª—ã (–≥—Ä–∞–¥—É—Å—ã)
        y_pred : array-like ‚Äî –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–µ —É–≥–ª—ã (–≥—Ä–∞–¥—É—Å—ã)
        title : str ‚Äî –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≥—Ä–∞—Ñ–∏–∫–æ–≤
    
    –í–û–ó–í–†–ê–©–ê–ï–¢:
        –°–ª–æ–≤–∞—Ä—å —Å –∫–ª—é—á–µ–≤—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏ –∫–∞—á–µ—Å—Ç–≤–∞:
          - mae: —Å—Ä–µ–¥–Ω—è—è –∞–±—Å–æ–ª—é—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ (–≥—Ä–∞–¥—É—Å—ã)
          - rmse: —Å—Ä–µ–¥–Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞ (–≥—Ä–∞–¥—É—Å—ã)
          - std_error: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—à–∏–±–∫–∏
          - max_error: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –∞–±—Å–æ–ª—é—Ç–Ω–∞—è –æ—à–∏–±–∫–∞
          - percentile_95: 95-–π –ø–µ—Ä—Ü–µ–Ω—Ç–∏–ª—å –∞–±—Å–æ–ª—é—Ç–Ω–æ–π –æ—à–∏–±–∫–∏
          - errors: –º–∞—Å—Å–∏–≤ –≤—Å–µ—Ö –æ—à–∏–±–æ–∫ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
    """
    y_true = np.asarray(y_true)
    y_pred = np.asarray(y_pred)
    
    # 1. –û—à–∏–±–∫–∏
    errors = angular_error_deg(y_true, y_pred)
    mae = np.mean(np.abs(errors))
    rmse = np.sqrt(np.mean(errors ** 2))
    std_error = np.std(errors)
    
    # 2. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    print(f"üîç –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—à–∏–±–æ–∫ (–≤ –≥—Ä–∞–¥—É—Å–∞—Ö):")
    print(f"  MAE (—Å—Ä–µ–¥–Ω—è—è –∞–±—Å–æ–ª—é—Ç–Ω–∞—è –æ—à–∏–±–∫–∞): {mae:.4f}¬∞")
    print(f"  RMSE (—Å—Ä–µ–¥–Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞): {rmse:.4f}¬∞")
    print(f"  –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—à–∏–±–∫–∏:  {std_error:.4f}¬∞")
    print(f"  –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞:           {np.max(np.abs(errors)):.4f}¬∞")
    print(f"  95-–π –ø–µ—Ä—Ü–µ–Ω—Ç–∏–ª—å –æ—à–∏–±–∫–∏:        {np.percentile(np.abs(errors), 95):.4f}¬∞")
    
    # 3. –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
    fig, axs = plt.subplots(1, 3, figsize=(15, 4))
    
    # a) Scatter plot: –∏—Å—Ç–∏–Ω–Ω—ã–π vs –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–π
    axs[0].scatter(y_true, y_pred, alpha=0.6, s=20)
    axs[0].plot([-3, 3], [-3, 3], 'r--', label='–ò–¥–µ–∞–ª—å–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ')
    axs[0].set_xlabel('–ò—Å—Ç–∏–Ω–Ω—ã–π —É–≥–æ–ª (¬∞)')
    axs[0].set_ylabel('–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–π —É–≥–æ–ª (¬∞)')
    axs[0].set_title('–ò—Å—Ç–∏–Ω–Ω—ã–π vs –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–π')
    axs[0].legend()
    axs[0].grid(True)
    
    # b) –ì–∏—Å—Ç–æ–≥—Ä–∞–º–º–∞ –æ—à–∏–±–æ–∫
    axs[1].hist(errors, bins=30, edgecolor='black', alpha=0.7)
    axs[1].axvline(0, color='red', linestyle='--')
    axs[1].set_xlabel('–û—à–∏–±–∫–∞ (¬∞)')
    axs[1].set_ylabel('–ß–∞—Å—Ç–æ—Ç–∞')
    axs[1].set_title(f'–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫\n(MAE = {mae:.4f}¬∞)')
    axs[1].grid(True)
    
    # c) –û—à–∏–±–∫–∏ –ø–æ –≤–µ–ª–∏—á–∏–Ω–µ –∏—Å—Ç–∏–Ω–Ω–æ–≥–æ —É–≥–ª–∞
    axs[2].scatter(y_true, errors, alpha=0.6, s=20)
    axs[2].axhline(0, color='red', linestyle='--')
    axs[2].set_xlabel('–ò—Å—Ç–∏–Ω–Ω—ã–π —É–≥–æ–ª (¬∞)')
    axs[2].set_ylabel('–û—à–∏–±–∫–∞ (¬∞)')
    axs[2].set_title('–û—à–∏–±–∫–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∏—Å—Ç–∏–Ω–Ω–æ–≥–æ —É–≥–ª–∞')
    axs[2].grid(True)
    
    plt.suptitle(title, fontsize=14)
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()
    
    return {
        'mae': mae,
        'rmse': rmse,
        'std_error': std_error,
        'max_error': np.max(np.abs(errors)),
        'percentile_95': np.percentile(np.abs(errors), 95),
        'errors': errors
    }



path_dir = Path(path[0])
all_data = pd.read_csv((path_dir / "combined_data_angle.csv"))

delta = 1
# analysis()

# –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –ø—Ä–∏–∑–Ω–∞–∫–∏ (X) –∏ —Ü–µ–ª–µ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é (y)
# –ü–æ—Å–ª–µ–¥–Ω–∏–π —Å—Ç–æ–ª–±–µ—Ü ‚Äî —É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞, –æ—Å—Ç–∞–ª—å–Ω—ã–µ ‚Äî –ø—Ä–∏–∑–Ω–∞–∫–∏ –∏–∑–º–µ—Ä–µ–Ω–Ω—ã—Ö —Å–º–µ—â–µ–Ω–∏–π
y = all_data.loc[:, all_data.columns[-1]]
X = all_data.loc[:, all_data.columns[:-1]]


# –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –æ–±—É—á–∞—é—â—É—é –∏ —Ç–µ—Å—Ç–æ–≤—É—é –≤—ã–±–æ—Ä–∫–∏ (50/50 –¥–ª—è –Ω–∞–¥—ë–∂–Ω–æ–π –æ—Ü–µ–Ω–∫–∏ –Ω–∞ —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5, random_state=1)
test_index = list(y_test.index)


# –ë–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å: –ª–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è (–±—ã—Å—Ç—Ä–∞—è, –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º–∞—è, —Ö–æ—Ä–æ—à–∏–π –±–µ–Ω—á–º–∞—Ä–∫)
model = LinearRegression()

# –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –º–æ–¥–µ–ª–∏ (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è):
# model = Ridge(alpha=1)  # –õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è —Å L2-—Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–µ–π (–±–æ—Ä—å–±–∞ —Å –º—É–ª—å—Ç–∏–∫–æ–ª–ª–∏–Ω–µ–∞—Ä–Ω–æ—Å—Ç—å—é)
# model = RandomForestRegressor(n_estimators=100, criterion='squared_error')  # –ê–Ω—Å–∞–º–±–ª—å –¥–µ—Ä–µ–≤—å–µ–≤ (–Ω–µ–ª–∏–Ω–µ–π–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏, —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –∫ –≤—ã–±—Ä–æ—Å–∞–º)
# model = XGBRegressor(n_estimators=249, max_depth=10, learning_rate=0.037, 
#                      eval_metric='mae', random_state=1, subsample=0.64, colsample_bytree=0.7)
# model = XGBRegressor(**bayes_opt(X, y))  # XGBoost —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏


# –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ –ø–æ–ª–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ (5 —Ñ–æ–ª–¥–æ–≤) –¥–ª—è –æ–±—ä–µ–∫—Ç–∏–≤–Ω–æ–π –æ—Ü–µ–Ω–∫–∏ –æ–±–æ–±—â–∞—é—â–µ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
print("–ó–Ω–∞—á–µ–Ω–∏–µ –∫—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏–∏ –º–æ–¥–µ–ª–∏ (MAE):", np.mean(cross_val_score(model, X, y, cv=5,
                                                                  scoring='neg_mean_absolute_error') * -1), "\n")
print("–ó–Ω–∞—á–µ–Ω–∏–µ –∫—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏–∏ –º–æ–¥–µ–ª–∏ (MSE):", np.mean(cross_val_score(model, X, y, cv=5,
                                                                  scoring='neg_mean_squared_error') * -1), "\n")

# –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –Ω–∞ –æ–±—É—á–∞—é—â–µ–π –≤—ã–±–æ—Ä–∫–µ
model.fit(X_train, y_train)


# –ò–∑–º–µ—Ä–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–∞ (–ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è) –¥–ª—è –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
# –í–∞–∂–Ω–æ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
start = perf_counter()
y_pred = model.predict(X_test)
finish = perf_counter()
print("–í—Ä–µ–º—è –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–∞ –º–æ–¥–µ–ª–∏:", round((finish - start) / X_test.shape[0] * 1000000, 5), "*10-6 —Å–µ–∫.\n")


# # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
# model.fit(np.array(X), y)  # –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –ø–æ–ª–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
# dump(model, 'angles_calc.joblib')


# –ü–æ–ª–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —É–≥–ª–∞ —Å –¥–µ—Ç–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π –∏ –≥—Ä–∞—Ñ–∏–∫–∞–º–∏
evaluate_angle_predictions(y_test, y_pred)