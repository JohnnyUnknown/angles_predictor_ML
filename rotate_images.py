"""
Скрипт для генерации набора обучающих изображений с имитацией поворотов (без смещений).

Назначение:
- Загружает исходные изображения из директории 'raw'
- Для каждого изображения создаёт серию кропов 300x300 пикселей:
  * С поворотами в диапазоне от -3.0° до +3.0° с шагом 0.05° (всего 121 угол)
  * Без смещений центра (фиксированный центр кропа)
- Сохраняет кропы в структурированную директорию 'angles/images' с именами,
  кодирующими параметры поворота
- Все кропы извлекаются из центра изображения после применения поворота

Формат имён файлов:
  0p0_0p0_угол.jpg
  Пример: "0p0_0p0_m2p50.jpg" → смещение (0,0), поворот -2.50°
  Особенности кодировки:
    '.' → 'p' (point)
    '-' → 'm' (minus)
    '+' → опускается (положительные значения без знака)
"""

import os
import numpy as np
import cv2 as cv
from pathlib import Path
from sys import path


# Директории для входных и выходных данных
RAW_DIR = Path(path[0] + "\\raw")          # Исходные изображения (входная директория)
ANGLES_DIR = Path(path[0] + "\\angles\\images")  # Выходные кропы с поворотами

# Параметры обработки
CROP_SIZE = 300            # Размер квадратного кропа (пиксели)
ANGLE_START = -3.0         # Начальный угол поворота (градусы)
ANGLE_END = 3.0            # Конечный угол поворота (градусы)
ANGLE_STEP = 0.05          # Шаг изменения угла (градусы)
ANGLES = int((abs(ANGLE_START) + ANGLE_END) / ANGLE_STEP + 1)  # Общее количество углов (121)

# Поддерживаемые форматы изображений (регистронезависимо)
SUPPORTED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp'}


def center_crop(img: np.ndarray) -> np.ndarray:
    """
    Извлекает центральный квадратный кроп заданного размера из изображения.
    
    Особенности:
      - Работает с изображениями любого размера ≥ CROP_SIZE
      - Автоматически корректирует координаты при граничных условиях
      - Гарантирует возврат кропа точного размера CROP_SIZE x CROP_SIZE
        (благодаря предварительной проверке размеров изображения)
    
    :param img: Исходное изображение (2D массив в градациях серого)
    :return: Центральный квадратный кроп размером CROP_SIZE x CROP_SIZE
    """
    h, w = img.shape[:2]  # Высота и ширина исходного изображения
    target = CROP_SIZE
    
    # Вычисление центра изображения
    cy, cx = h // 2, w // 2
    
    # Расчёт координат кропа с защитой от выхода за границы
    y1 = max(0, cy - target // 2)
    x1 = max(0, cx - target // 2)
    y2 = min(h, y1 + target)
    x2 = min(w, x1 + target)
    
    return img[y1:y2, x1:x2]


def rotate_image(img: np.ndarray, angle_deg: float) -> np.ndarray:
    """
    Поворачивает изображение вокруг его геометрического центра.
    
    Важные особенности:
      - Размер выходного изображения сохраняется равным входному
      - Пустые области (появляющиеся после поворота) заполняются чёрным цветом
      - Используется билинейная интерполяция (по умолчанию в warpAffine)
      - Центр поворота точно совпадает с центром изображения
    
    :param img: Исходное изображение (2D массив)
    :param angle_deg: Угол поворота в градусах 
                      (положительное значение → против часовой стрелки)
    :return: Повёрнутое изображение того же размера
    """
    height, width = img.shape[:2]
    center_x, center_y = (width / 2, height / 2)
    
    # Создание матрицы аффинного преобразования для поворота
    matrix = cv.getRotationMatrix2D((center_x, center_y), angle_deg, 1.0)
    
    # Применение поворота с сохранением исходных размеров изображения
    rotated = cv.warpAffine(
        img, 
        matrix, 
        (width, height),
        flags=cv.INTER_LINEAR,      # Билинейная интерполяция для качества
        borderMode=cv.BORDER_CONSTANT,  # Чёрная заливка пустых областей
        borderValue=0
    )
    return rotated


def main():
    """
    Основной цикл генерации обучающих кропов с поворотами.
    
    Алгоритм работы:
      1. Создание выходной директории (если не существует)
      2. Генерация массива углов поворота: [-3.0, -2.95, ..., 0, ..., 2.95, 3.0]
      3. Для каждого изображения в RAW_DIR:
          - Загрузка в градациях серого
          - Проверка минимального размера (≥300x300 пикселей)
          - Для каждого угла поворота:
              * Применение поворота к полному изображению
              * Извлечение центрального кропа 300x300
              * Сохранение с кодированием угла в имени файла
      4. Все кропы сохраняются с фиксированным смещением (0,0) и переменным углом
    """
    # Создание структуры выходных директорий
    os.makedirs(ANGLES_DIR, exist_ok=True)
    
    # Генерация равномерной сетки углов поворота
    angles = np.linspace(ANGLE_START, ANGLE_END, ANGLES)
    print(f"Генерация кропов для {ANGLES} углов поворота: от {ANGLE_START}° до {ANGLE_END}° с шагом {ANGLE_STEP}°")

    # Обработка каждого файла в директории исходных изображений
    for filename in os.listdir(RAW_DIR):
        name, ext = os.path.splitext(filename)
        
        # Пропуск файлов с неподдерживаемыми расширениями
        if ext.lower() not in SUPPORTED_EXTENSIONS:
            continue

        img_path = os.path.join(RAW_DIR, filename)
        
        # Загрузка изображения в градациях серого
        try:
            img = cv.imread(img_path, cv.IMREAD_GRAYSCALE)
            if img is None:
                raise ValueError("Изображение не может быть загружено (повреждено или неподдерживаемый формат)")
        except Exception as e:
            print(f"Не удалось открыть {img_path}: {e}")
            continue

        # Проверка минимального размера изображения (исправление бага: h, w вместо w, h)
        h, w = img.shape[:2]
        if w < CROP_SIZE or h < CROP_SIZE:
            print(f"Пропущено {filename}: размер ({w}x{h}) меньше минимального {CROP_SIZE}x{CROP_SIZE}")
            continue

        # Создание поддиректории для текущего изображения
        output_subdir = os.path.join(ANGLES_DIR, ("rotate_" + name))
        os.makedirs(output_subdir, exist_ok=True)

        # Генерация кропов для всех углов поворота
        for angle in angles:
            # 1. Поворот полного изображения
            rotated = rotate_image(img, angle)
            
            # 2. Извлечение центрального кропа
            cropped = center_crop(rotated)
            
            # 3. Форматирование угла для имени файла:
            #    Пример: -2.5 → "-2.50" → "m2p50"
            angle_str = f"{angle:+.2f}"  # Формат с двумя знаками после запятой и знаком
            safe_angle = (angle_str.replace('+', '')  # Удаление '+' для положительных значений
                                 .replace('-', 'm')   # Замена '-' на 'm'
                                 .replace('.', 'p'))  # Замена '.' на 'p'
            
            # 4. Формирование имени файла: "0p0_0p0_угол.jpg"
            #    Смещение всегда (0,0) - поворот относительно центра без сдвига
            out_filename = f"0p0_0p0_{safe_angle}.jpg"
            out_path = os.path.join(output_subdir, out_filename)
            
            # 5. Сохранение кропа с оптимальным качеством JPEG
            cv.imwrite(out_path, cropped, [int(cv.IMWRITE_JPEG_QUALITY), 95])

        print(f"Обработано: {filename} → {ANGLES} кропов сохранено в {os.path.basename(output_subdir)}")

    print(f"\nВсе изображения обработаны! Сгенерировано кропов для {len(os.listdir(RAW_DIR))} исходных изображений.")


if __name__ == "__main__":
    main()